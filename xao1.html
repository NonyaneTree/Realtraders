<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>XIO Assistant</title>
  <meta name="google-adsense-account" content="ca-pub-7221396727211259">
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; background: #eef1f5; font-family: 'Segoe UI', sans-serif; min-height: 100vh; overflow-y: auto; }
    .chat-container { width: 100%; min-height: 100vh; display: flex; flex-direction: column; background: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.05); }
    .header { background-color: #0066ff; color: white; padding: 15px 20px; font-size: 18px; font-weight: bold; flex-shrink: 0; }
    #messages { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; -webkit-overflow-scrolling: touch; }
    .msg { max-width: 85%; padding: 12px 15px; border-radius: 15px; line-height: 1.5; word-break: break-word; display: flex; align-items: flex-start; }
    .msg img.xio-icon { width: 34px; height: 34px; margin-right: 8px; margin-top: 4px; flex-shrink: 0; }
    .msg .pattern-img { max-width: 100%; max-height: 300px; height: auto; border: 1px solid #ddd; border-radius: 8px; margin-top: 10px; display: block; object-fit: contain; }
    .user { align-self: flex-end; background: #d7ebff; color: #003366; border-top-right-radius: 0; }
    .xio { align-self: flex-start; background: #f1f1f1; color: #222; border-top-left-radius: 0; }
    
    /* Combined Search Bar Styles */
    .search-container { 
      display: flex; 
      width: 100%; 
      padding: 10px; 
      background: #fff; 
      border-top: 1px solid #ddd; 
      flex-shrink: 0; 
      align-items: center;
      gap: 8px;
    }
    #searchInput { 
      flex: 1; 
      padding: 12px 15px; 
      border: 1px solid #ddd; 
      border-radius: 20px; 
      font-size: 16px; 
    }
    #searchInput:focus { 
      outline: none; 
      border-color: #0066ff; 
    }
    .photo-icon {
      background: #0066ff;
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      flex-shrink: 0;
    }
    .photo-icon:hover {
      background: #0055cc;
    }
    
    .loading-spinner { 
      border: 3px solid rgba(0,0,0,0.1); 
      border-radius: 50%; 
      border-top: 3px solid #0066ff; 
      width: 20px; 
      height: 20px; 
      animation: spin 1s linear infinite; 
      margin: 0 auto; 
    }
    @keyframes spin { 
      0% { transform: rotate(0deg); } 
      100% { transform: rotate(360deg); } 
    }
    
    @media screen and (max-width: 480px) {
      .msg { max-width: 90%; }
      #searchInput { padding: 10px 15px; }
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div class="header">ðŸ¤– XIO Chat 3.3.4 -- AI Forex Assistant</div>
    <div id="messages"></div>
    
    <!-- Combined Search Bar -->
    <div class="search-container">
      <input type="text" id="searchInput" placeholder="Type your question...">
      <div class="photo-icon" onclick="window.location.href='search.html'">ðŸ“·</div>
    </div>
  </div>

  <script>
    // Telegram configuration
    const GENERAL_BOT_TOKEN = 'YOUR_TELEGRAM_BOT_TOKEN';
    const GENERAL_CHAT_ID = 'YOUR_CHAT_ID';
    const TECH_BOT_TOKEN = "YOUR_TECHNICAL_BOT_TOKEN";
    const TECH_CHAT_ID = "YOUR_TECHNICAL_CHAT_ID";
    const FUND_BOT_TOKEN = "YOUR_FUNDAMENTAL_BOT_TOKEN";
    const FUND_CHAT_ID = "YOUR_FUNDAMENTAL_CHAT_ID";
    
    let qaPairs = [];
    const responses = {};
    let telegramMessages = [];
    const synonyms = {};

    async function initialize() {
      await loadResponses();
      await fetchTelegramMessages();
      setInterval(fetchTelegramMessages, 300000);
      
      // Setup search input event listener
      document.getElementById("searchInput").addEventListener("keypress", (e) => {
        if (e.key === "Enter") sendMessage();
      });
    }

    async function fetchTelegramMessages() {
      try {
        const response = await fetch(`https://api.telegram.org/bot${GENERAL_BOT_TOKEN}/getUpdates`);
        const data = await response.json();
        if (data.ok && data.result.length > 0) {
          telegramMessages = data.result
            .filter(update => update.message && update.message.chat.id.toString() === GENERAL_CHAT_ID)
            .map(update => ({
              text: update.message.text,
              date: new Date(update.message.date * 1000),
              message_id: update.message.message_id
            }));
        }
      } catch (error) {
        console.error('Error fetching Telegram messages:', error);
      }
    }

    async function sendToTelegram(message) {
      try {
        await fetch(`https://api.telegram.org/bot${GENERAL_BOT_TOKEN}/sendMessage`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ chat_id: GENERAL_CHAT_ID, text: message })
        });
        await fetchTelegramMessages();
      } catch (error) {
        console.error('Error sending to Telegram:', error);
      }
    }

    function searchTelegramMessages(query) {
      if (!telegramMessages.length) return null;
      const lowerQuery = query.toLowerCase();
      return telegramMessages.filter(msg => 
        msg.text && msg.text.toLowerCase().includes(lowerQuery)
      ).slice(0, 3);
    }

    async function loadResponses() {
      try {
        const response = await fetch('xio2.html');
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const scriptContent = doc.querySelector('script').textContent;
        const responsesMatch = scriptContent.match(/const responses = ({[\s\S]*?});/);
        
        if (responsesMatch && responsesMatch[1]) {
          const responsesObj = new Function(`return ${responsesMatch[1]}`)();
          Object.assign(responses, responsesObj);
          
          for (const [question, data] of Object.entries(responses)) {
            qaPairs.push({
              question: question.toLowerCase(),
              answer: data.description,
              image: data.image || null,
              source: 'local'
            });
          }
        }
      } catch (error) {
        console.error('Error loading xio2.html:', error);
        addMessage("XIO", "I'm having trouble loading my knowledge base. Please try again later.", "xio");
      }
    }

    function sendMessage() {
      const input = document.getElementById("searchInput");
      const text = input.value.trim();
      if (!text) return;

      addMessage("You", text, "user");
      const thinkingMsg = addMessage("XIO", "<div class='loading-spinner'></div>", "xio", true);
      
      setTimeout(async () => {
        thinkingMsg.remove();
        const reply = await getAnswer(text.toLowerCase());
        addMessage("XIO", reply, "xio");
      }, 1000);

      input.value = "";
    }

    function addMessage(sender, text, cls, returnElement = false) {
      const msg = document.createElement("div");
      msg.className = `msg ${cls}`;
      msg.innerHTML = cls === "xio" 
        ? `<img src="xioicon.png" alt="XIO Icon" class="xio-icon"><div>${text}</div>`
        : `<div><strong>${sender}:</strong> ${text}</div>`;
      
      document.getElementById("messages").appendChild(msg);
      msg.scrollIntoView({ behavior: 'smooth' });
      return returnElement ? msg : null;
    }

    async function getAnswer(userInput) {
      if (!qaPairs.length) {
        return "My knowledge base is still loading. Please try again in a moment.";
      }

      // Check for signal requests first
      const lowerInput = userInput.toLowerCase();
      if (lowerInput.includes("technical signals")) {
        return await fetchSignalMessages(TECH_BOT_TOKEN, TECH_CHAT_ID, "technical");
      }
      if (lowerInput.includes("fundamental signals")) {
        return await fetchSignalMessages(FUND_BOT_TOKEN, FUND_CHAT_ID, "fundamental");
      }

      // Existing QA matching
      const exactMatch = qaPairs.find(pair => pair.question === userInput);
      if (exactMatch) return formatResponse(exactMatch);

      const expandedInput = expandSynonyms(userInput);
      for (const pair of qaPairs) {
        const expandedQuestion = expandSynonyms(pair.question);
        if (expandedInput.includes(expandedQuestion) || expandedQuestion.includes(expandedInput)) {
          return formatResponse(pair);
        }
        
        const inputWords = expandedInput.split(/\s+/);
        const questionWords = expandedQuestion.split(/\s+/);
        const matchScore = inputWords.filter(word => questionWords.includes(word)).length;
        
        if (matchScore >= Math.min(2, questionWords.length)) {
          return formatResponse(pair);
        }
      }

      // Telegram search fallback
      const telegramResults = searchTelegramMessages(userInput);
      if (telegramResults && telegramResults.length) {
        let telegramResponse = "I found relevant discussions:<br><br>";
        telegramResults.forEach((msg, index) => {
          telegramResponse += `<strong>Message ${index + 1}:</strong> ${msg.text}<br>`;
          if (msg.date) {
            telegramResponse += `<small>Posted on ${msg.date.toLocaleString()}</small><br><br>`;
          }
        });
        return telegramResponse;
      }

      // Final fallback
      const availableTopics = [...new Set(qaPairs.map(pair => pair.question))].slice(0, 5).join(", ");
      return `I'm not sure about that. Try asking about: ${availableTopics} or check our Telegram group.`;
    }

    async function fetchSignalMessages(token, chatId, type) {
      try {
        const res = await fetch(`https://api.telegram.org/bot${token}/getUpdates`);
        const data = await res.json();
        if (data.result && data.result.length > 0) {
          const messages = data.result
            .filter(m => m.message && m.message.chat && m.message.chat.id == chatId)
            .map(m => m.message.text)
            .filter(t => t)
            .slice(0, 5);
          
          if (messages.length) {
            return `<strong>Recent ${type} signals:</strong><br><br>${messages.join("<br><br>")}`;
          }
        }
        return `No recent ${type} signals found.`;
      } catch (err) {
        return `Error fetching ${type} signals.`;
      }
    }

    function expandSynonyms(text) {
      let result = text.toLowerCase();
      for (const [base, alts] of Object.entries(synonyms)) {
        for (const alt of alts) {
          const regex = new RegExp(`\\b${alt}\\b`, 'gi');
          result = result.replace(regex, base);
        }
      }
      return result;
    }

    function formatResponse(pair) {
      let response = pair.answer;
      if (pair.image) {
        response += `<img src="${pair.image}" alt="${pair.question}" class="pattern-img">`;
      }
      if (pair.source === 'telegram') {
        response += `<br><small>Source: Telegram group</small>`;
      }
      return response;
    }

    // Initialize the application
    initialize();
  </script>
</body>
</html>
